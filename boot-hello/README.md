1）boot-hello 是一个引导程序，nasm语法纯汇编编写，引导程序最终编译成 bin 二进制格式，并非 elf 格式<br>
2）引导程序代码初始需要增加 org 0x7c00 伪指令，是因为cpu上电后，在执行完 bios 指令之后，会把在 bios 里设置的第一启动盘，第一个分区的 512 字节并且以 0x55aa 结尾的数据作为引导程序，加载到内存 0x7c00 处执行（加载到这个地址只是一个调用约定而已，历史遗留问题，实际加载到别的空闲地址一样可以运行）。但引导程序在使用 nasm 编译的时候，编译器默认计算的虚拟地址基地址是 0x0000，编译器并不知道代码最终会在内存什么地址里运行（这个由操作系统决定，没有操作系统之前由引导程序决定），所以计算指令和数据的位置时，地址偏移都是依据 0x0000 来计算的，等到代码实际被加载到内存中之后，这个地址已经不对了，读取数据会发生错误<br>
3）代码里用的是 [bits 16] 而不是 [bits 32]，因为 cpu 刚启动的时候是运行在 16 位实模式之下的，这两种方式编译的最终的机器指令不同<br>
4）在 16 位实模式之下，寄存器用的还是 ax，bx 等，eax， ebx 等不可用，cpu 地址线也只有 20 位，寻址能力只有 1m，虽然现代 cpu 早已经是 64 位了，但cpu 初始化的时候运行在 16位 是为了兼容，也就是说20年前开发的 16 位程序在最新的 cpu 上也能运行

<code>
nasm -f bin boot-hello.asm -o boot-hello.bin
</code>
<br>
<code>
dd if=boot-hello.bin of=a.img bs=512 count=1 conv=notrunc	
</code>
<br>
<code>
bochs -f bochsrc.txt	
</code>
<br>

