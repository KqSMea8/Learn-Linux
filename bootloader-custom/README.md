本文采用自己编写的引导程序 bootloader 来引导操作系统内核，在汇编代码下从磁盘读取内核文件加载，然后切换到保护模式，再进入内核代码执行（c代码）<br>

1）内核引导程序和内核镜像是 2 个不相关的文件，各自独立编译<br>
2）引导程序是汇编开发，编译出二进制 bin 文件，运行在实模式下<br>
3）内核镜像是 c 和 asm 混合开发，编译出 32 位或者 64 位的 elf 文件<br>
4）自定制开发的 bootloader 暂无法识别 elf 文件，不能像 grub 那样直接加载 elf 内核，所以内核镜像编译完之后需要用 objcopy 工具导出 elf 内核中真正的二进制 bin 文件（去掉 elf 文件头部那些）<br>
5）将 bootloader 和导出后的内核 bin 文件直接二进制拼接起来，写入磁盘镜像，可正常使用<br>
6）bootloader 启动之后从磁盘读取内核镜像到内存，加载到 0x1000 的内存地址（这个由 load_kernel.asm 代码决定，因此内核编译时需要在 link.ld 里指指定代码段地址也为 0x1000，否则代码段缺省都是基于 0 来计算偏移），并设置好 gdt，切换到保护模式，再跳转到 0x1000 内核代码入口<br>
7）也可以修改 link.ld 和 load_kernel.asm 里的内核加载地址为 0x9000，但一定要使用空闲没有别的程序占用的内存，比如不能占用 bios，显存，外部硬件设备那些地址空间<br>
8）内核加载到内存之后，执行内核入口函数之前，需要从实模式切换为保护模式，因为内核是在32位或者64位下开发编译的，机器指令不同，不能直接在实模式下运行<br>



